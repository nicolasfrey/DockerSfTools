#!/usr/bin/env bash

BRANCHE='master'

# Version
version () {
   VERSION='2.1.1'
   echo ""
   echo -e "\e[34mbin/app\e[39m version \e[33m${VERSION}\e[39m"
   echo ""
}

selfupdate () {
  curl --create-dirs -k -o bin/app -X GET https://raw.githubusercontent.com/nicolasfrey/DockerSfTools/${BRANCHE}/bin/app
  chmod +x bin/app
  bin/app version
}

displayError () {
   echo -e "\e[41m"
   echo -e "\n  An error occured !!! Please, check your command history. "
   echo -e "\e[49m"
   exit
}

# init project
init () {
   # Docker recreate
   docker-compose up -d --force-recreate || displayError

   # Update()
   echo ""
   update
   echo ""

   echo -e "\e[44m\e[30m"
   echo -e "\n  Please, add line \"127.0.0.1 ${APP__HTTP_URL}\" in your hosts file to access http://${APP__HTTP_URL}  "
   echo -e "\e[49m\e[39m"
}

# update project
update () {
   echo "----> Converting file to Unix format"
   ls -d -1 app/bin/* app/.env*
   dos2unix -q app/bin/* app/.env*
   echo " [OK] Converting file to Unix format"

   echo ""

   echo "----> Set executable"
   ls -d -1 bin/* app/bin/*
   chmod u+x bin/* app/bin/*
   echo " [OK] Set executable"

   echo ""

   echo "----> Add githooks"
   githooks
   echo " [OK] Githooks added"

   echo ""

   echo "----> Add default config"
   config
   echo " [OK] Default config added"

   echo ""

   echo "----> Install dependency"
   docker-compose run --rm -u "$USER":"$GROUP" phpcli composer install || displayError
   echo " [OK] Dependency installed"

   echo ""

   echo "----> Initialize database"
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:schema:drop --full-database --force || displayError
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:database:create --if-not-exists || displayError
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:schema:update --force || displayError
   echo " [OK] Database initialized"

   echo ""

   if isWeb; then
       echo "----> Create directory"
       docker-compose run --rm -u "$USER":"$GROUP" phpcli bash -c "
            mkdir -p public/upload &&
            chmod 777 public/upload -R
         " || displayError
       echo " [OK] Directories created"
       echo ""
   fi

   echo "----> Load fixture"
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:fixtures:load -n --purge-with-truncate  || displayError
   echo " [OK] Fixture loaded"
}

# remove containers, volumes and local images for this project
destroy () {
   if isWeb; then
       echo "----> Remove directory"
       docker-compose run --rm -u "$USER":"$GROUP" phpcli rm -rf public/upload public/build vendor node_modules var bin/.phpunit
       rm -f .docker/oracle/init/.cache
       echo " [OK] Directories removed"
       echo ""
   fi

   echo "----> Stop and remove docker images"
   docker-compose down -v --rmi local
   echo " [OK] Docker images removed"
}

# Install git hooks
githooks () {
  PRE_COMMIT_EXISTS=$([ -e .git/hooks/pre-commit ] && echo 1 || echo 0)
  COMMIT_MSG_EXISTS=$([ -e .git/hooks/commit-msg ] && echo 1 || echo 0)

  curl -s -o .git/hooks/pre-commit -X GET https://raw.githubusercontent.com/nicolasfrey/DockerSfTools/${BRANCHE}/config/pre-commit
  curl -s -o .git/hooks/commit-msg -X GET https://raw.githubusercontent.com/nicolasfrey/DockerSfTools/${BRANCHE}/config/commit-msg
  chmod +x .git/hooks/*;
  dos2unix -q .git/hooks/*

  if [ "$PRE_COMMIT_EXISTS" = 0 ]; then
      echo "Pre-commit git hook is installed!"
  else
      echo "Pre-commit git hook is updated!"
  fi

  if [ "$COMMIT_MSG_EXISTS" = 0 ]; then
      echo "Commit-msg git hook is installed!"
  else
      echo "Commit-msg git hook is updated!"
  fi
}

# Initialize config
config () {
  [ -f ../grumphp.yml ] || curl -s -o grumphp.yml -X GET https://raw.githubusercontent.com/nicolasfrey/DockerSfTools/${BRANCHE}/config/sample-grumphp.yml
  [ -f .php-cs-fixer.dist.php ] || curl -s -o app/.php-cs-fixer.dist.php -X GET https://raw.githubusercontent.com/nicolasfrey/DockerSfTools/${BRANCHE}/config/sample-cs-fixer.php
}

# start docker
start () {
    docker-compose up -d
}

# stop docker
stop () {
    docker-compose stop
}

# restart docker
restart () {
    docker-compose stop
    docker-compose up -d
}

# run Composer inside the app container
composer () {
    declare ARGS=$*
    docker-compose run --rm -u "$USER":"$GROUP" phpcli composer ${ARGS}
}

# run the Symfony console inside the app container
console () {
    declare ARGS=$*
    docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console ${ARGS}
}

# run bash
bash () {
    docker-compose run --rm -u "$USER":"$GROUP" phpcli bash
}

# exec a php command into app container
php () {
    declare ARGS=$*
    docker-compose run --rm -u "$USER":"$GROUP" phpcli php ${ARGS}
}

# run phpUnit
phpunit () {
   declare ARGS=$*

   if [[ ${ARGS} == *"--coverage"* ]]; then
      docker-compose run --rm -u "$USER":"$GROUP" phpcli phpdbg -qrr ./bin/phpunit "${ARGS/--coverage/}"
   else
      docker-compose run --rm -u "$USER":"$GROUP" phpcli ./bin/phpunit --no-coverage ${ARGS}
   fi
}

# run php-cs-fixer
grumphp () {
   declare ARGS="$*"

   if [[ -z $1 ]]; then
      docker-compose run --rm phpcli grumphp --config=../grumphp.yml run
   elif [ $1 == 'init' ]; then
       githooks
   else
      docker-compose run --rm phpcli grumphp --config=../grumphp.yml run -v ${ARGS}
   fi
}

# run Update schema and reload fixture
dbreload () {
   docker-compose run --rm -u "$USER":"$GROUP" phpcli rm -rf public/upload
   docker-compose run --rm -u "$USER":"$GROUP" phpcli mkdir -p public/upload
   docker-compose run --rm -u "$USER":"$GROUP" phpcli chmod 777 public/upload -R

   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:schema:drop --full-database --force
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:schema:update --force
   docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:fixtures:load -n --purge-with-truncate
}

dbload () {
   declare SOURCE=$1
   declare IGNORE=$2

   if [[ -z "${SOURCE}" ]]; then
      usage
      exit 0
   fi

   if [[ ! ${SOURCE} =~ ^PROD|STAGING$ ]]; then
      echo "${SOURCE} must be PROD or STAGING"
      exit 1
   fi

   if [[ -n "${IGNORE}" ]] && [[ ${IGNORE} != '--ignore-excludes' ]]; then
      echo -e "\e[41m"
      echo -e "\n Parameter \"${IGNORE}\" is not defined ! \n\n Did you mean one of these? \n    --ignore-excludes"
      echo -e "\e[49m"
      exit
   fi

   DATABASE="APP_${SOURCE}__DATABASE_URL"

   pattern='^(pgsql):\/\/(.*):(.*)@(.*):([0-9]*)\/([a-zA-Z0-9_\-]*)[\s]*$'
   if [[ ${!DATABASE} =~ $pattern ]]; then
      DB_PROTOCOL=${BASH_REMATCH[1]}
      DB_USER=${BASH_REMATCH[2]}
      DB_PASSWORD=${BASH_REMATCH[3]}
      DB_HOST=${BASH_REMATCH[4]}
      DB_PORT=${BASH_REMATCH[5]}
      DB_DBNAME=${BASH_REMATCH[6]}
   fi

   if [[ -z "${DB_PROTOCOL}" ]] || [[ -z "${DB_HOST}" ]] || [[ -z "${DB_DBNAME}" ]] ; then
      echo "You must have host and DB name !"
      exit 1
   fi

   CURRENT_USER=$(id -u -n)
   BACKUP_FILE="dump_$(date '+%Y%m%d%H%M').sql.backup"
   STR_EXCLUDE_TABLE_DATA=''

   if [[ "${IGNORE}" != '--ignore-excludes' ]] && [[ "${APP__PSQL_EXCLUDE_TABLE_DATA}" = *[!\ ]* ]]; then
      EXCLUDE_DATA=$(echo "${APP__PSQL_EXCLUDE_TABLE_DATA}" | tr ",; " "\n")

      for DATA in $EXCLUDE_DATA
      do
          STR_EXCLUDE_TABLE_DATA+=" --exclude-table-data ${DATA}"
      done
   fi

   echo "----> Backup ${SOURCE} database"
   ssh "${CURRENT_USER}@${DB_HOST}" PGPASSWORD="${DB_PASSWORD}" pg_dump "${STR_EXCLUDE_TABLE_DATA}" --compress=9 --verbose --format=c --host=localhost --username="${DB_USER}" --dbname="${DB_DBNAME}" > ".docker/postgres/backup/${BACKUP_FILE}"
   echo " [OK] Backup ${SOURCE} database"
   echo ""

   echo "----> Clean localhost database"

   SEQUENCES=$(docker-compose exec -T postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" -t --command "SELECT string_agg(sequence_schema || '.\"' || sequence_name, '\",') FROM information_schema.sequences where sequence_catalog = '${APP__PSQL_DATABASE}'")
   if [[ "${SEQUENCES}" = *[!\ ]* ]]; then
      echo "Dropping sequences:${SEQUENCES}"
      docker-compose exec postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" --command "DROP SEQUENCE IF EXISTS ${SEQUENCES} CASCADE"
   fi

   VIEWS=$(docker-compose exec -T postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" -t --command "SELECT string_agg(table_schema || '.\"' || table_name || '\"', ',') FROM information_schema.tables where table_catalog = '${APP__PSQL_DATABASE}' AND table_schema not in('pg_catalog', 'information_schema') AND table_type='VIEW'")
   if [[ "${VIEWS}" = *[!\ ]* ]]; then
      echo "Dropping views:${VIEWS}"
      docker-compose exec postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" --command "DROP VIEW IF EXISTS ${VIEWS} CASCADE"
   fi

   BASETBLS=$(docker-compose exec -T postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" -t --command "SELECT string_agg(table_schema || '.\"' || table_name || '\"', ',') FROM information_schema.tables where table_catalog = '${APP__PSQL_DATABASE}' AND table_schema not in('pg_catalog', 'information_schema') AND table_type='BASE TABLE'")
   if [[ "${BASETBLS}" = *[!\ ]* ]]; then
      echo "Dropping tables:${BASETBLS}"
      docker-compose exec postgres psql --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" --command "DROP TABLE IF EXISTS ${BASETBLS} CASCADE"
   fi

   echo " [OK] Clean localhost database"
   echo ""

   echo "----> Restore database to localhost"
   docker-compose exec postgres pg_restore --format=c --verbose --clean --no-privileges --no-owner --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" /var/backup/${BACKUP_FILE}
   echo " [OK] Restore database to localhost"
   echo ""

   echo "----> Remove backup file"
   rm -v ".docker/postgres/backup/${BACKUP_FILE}"
   echo " [OK] Remove backup file"

   echo ""
   echo -e "\e[34mDo you want to execute a migration in database '${DB_DBNAME}' ? (\e[33my/n\e[34m)\e[39m"
   read -n 1
   echo ""
   if [[ $REPLY =~ ^[Yy]$ ]]; then
      docker-compose run --rm -u "$USER":"$GROUP" phpcli bin/console doctrine:migrations:migrate -n
   fi
}

fileload () {
   declare SOURCE=$1

   if [[ -z "${SOURCE}" ]]; then
      usage
      exit 0
   fi

   if [[ ! ${SOURCE} =~ ^PROD|STAGING$ ]]; then
      echo "${SOURCE} must be PROD or STAGING"
      exit 1
   fi

   UPLOAD_DIR="APP_${SOURCE}__UPLOAD_DIR"
   SERVER_IP="APP_${SOURCE}__SERVER_IP"
   SRC_PATH="APP_${SOURCE}__SRC_PATH"
   CURRENT_USER=$(id -u -n)

   echo "----> Rsync ${!UPLOAD_DIR} directory"
   rsync -av "deploy@${!SERVER_IP}:${!SRC_PATH}/current/${APP__SYMFONY_APP_PATH}/public/upload/*" "./${APP__SYMFONY_APP_PATH}/public/upload/"
   echo " [OK] Rsync ${!UPLOAD_DIR} directory"
   echo ""

   echo "----> Change permissions"
   docker-compose run --rm -u "$USER":"$GROUP" phpcli chmod 777 public/upload -R
   echo " [OK] Change permissions"
}

backup () {
   gzfile=$(echo `date '+%Y%m%d%H%M'`.backup.gz)

   docker-compose exec postgres bash -c "PGPASSWORD="${APP__PSQL_PASSWORD}" pg_dump --compress=9 --verbose --format=c --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" > /var/backup/${gzfile}"
}

restore () {
   declare FILENAME=$1

   if [[ "${FILENAME}" == 'latest' ]]; then
      FILENAME=$(docker-compose exec postgres bash -c "find ./var/backup -name *.backup.gz  -printf '%f\n' | sort -n | tail -n 1 | tr -dc '[[:print:]]'")
   fi

   if [[ -z ${FILENAME} ]]; then
      docker-compose exec postgres bash -c "find ./var/backup -name *.backup.gz  -printf '%f\n'"
      exit 0
   fi

   echo "Restore \"${FILENAME}\" backup"
   docker-compose exec postgres pg_restore --format=c --verbose --clean --no-privileges --no-owner --host=localhost --username="${APP__PSQL_USER}" --dbname="${APP__PSQL_DATABASE}" /var/backup/${FILENAME}
}

# Return symfony logs
sflogs () {
   docker-compose exec -it -u "$USER":"$GROUP" phpfpm bash -c "tail -f var/log/dev.log"
}

usage () {
    echo "usage: bin/app COMMAND [ARGUMENTS]

    selfupdate                                     Updates bin/app to the latest version.

    init                                           Initialize project
    update                                         Update current project (Reload db, launch composer install)
    destroy                                        Remove all the project Docker containers with their volumes

    start                                          Start project
    stop                                           Stop project
    restart                                        Restart project

    composer                                       Use Composer inside the app container
    console                                        Use the Symfony console
    bash                                           Use bash inside the app container
    php                                            Executes a php command inside the app container

    phpunit                                        Executes a phpUnit Tests. Add --coverage for coverage support
    grumphp <init|run...>                          Executes multiple tasks

    dbreload                                       Update schema and reload fixture
    dbload <PROD|STAGING> --ignore-excludes        Load choose environment DB into localhost
    fileload <PROD|STAGING>                        Load choose environment public files into local

    backup                                         Backup database in .docker/postgres/YmdHi.backup.gz
    restore <filename|latest>                      Restore database

    sflogs                                         Return sf logs.
    "
}

# .env loading in the shell
dotenv () {
   # Ajout d'un prefix APP__ sur les variables, sinon, on a un conflit avec docker
   if [[ -f .env ]]; then
      eval $(grep -v -e "^#" .env | sed "/^$/d" | xargs -I {} echo export \'APP__{}\')
   fi

   if [[ -f .env.local ]]; then
      eval $(grep -v -e "^#" .env.local | sed "/^$/d" | xargs -I {} echo export \'APP__{}\')
   fi

   if isDosFile "${APP__SYMFONY_APP_PATH}/.env" || isDosFile "${APP__SYMFONY_APP_PATH}/.env.staging" || isDosFile "${APP__SYMFONY_APP_PATH}/.env.prod" || isDosFile ".env"; then
        echo -e "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n!!!!!!! Check line separator configuration !!!!!!!\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
        exit 1
   fi

   # Lecture .env.prod si trouvé
   if [[ -f ${APP__SYMFONY_APP_PATH}/.env.prod ]]; then
      eval $(grep -P -e "^(DATABASE_URL|UPLOAD_DIR|SERVER_IP|SRC_PATH)" ${APP__SYMFONY_APP_PATH}/.env.prod | xargs -I {} echo export \'APP_PROD__{}\')
   fi

   # Lecture .env.staging si trouvé
   if [[ -f ${APP__SYMFONY_APP_PATH}/.env.staging ]]; then
      eval $(grep -P -e "^(DATABASE_URL|UPLOAD_DIR|SERVER_IP|SRC_PATH)" ${APP__SYMFONY_APP_PATH}/.env.staging | xargs -I {} echo export \'APP_STAGING__{}\')
   fi
}

isDosFile() {
    if [[ -f $1 ]]; then
       [[ $(dos2unix < $1 | cmp - $1 | wc -c) -gt 0 ]]
    fi
}

isWeb () {
  APP__IS_WEB="${APP__HTTP_URL//[$'\t\r\n ']}"

  if [[ -z ${APP__IS_WEB} ]]; then
    return 1
  else
    return 0
  fi
}

main () {
   if [[ -z $1 ]]; then
      usage
      exit 0
   fi

   if [[ ! $1 =~ ^(version|init|update|start|stop|restart|bash|destroy|console|composer|php|phpunit|phpcsf|backup|restore|dbload|fileload|dbreload|sflogs|grumphp|selfupdate)$ ]]; then
      echo "$1 is not a supported command"
      exit 1
   fi

   # Run dotenv
   dotenv

   # Get current user/group
   USER='docker'
   GROUP='docker'

   # Run command
   "$@"
}

main "$@"